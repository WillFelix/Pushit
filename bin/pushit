#!/bin/bash

get_redmine_token(){
		echo $(grep "^export REDMINE_API_TOKEN=.*" $HOME/.bash_profile | sed -e 's/export REDMINE_API_TOKEN=//g')
}

config_redmine(){
	red_token="$1"
	if [ "$red_token" == "" ]; then
		printf "You can find your API key on your account page ( /my/account ) when logged in.\n"
		read -p "Insert here your REDMINE API TOKEN: " red_token
	fi

	echo "export REDMINE_API_TOKEN=$red_token" >> ~/.bash_profile
	if [ -e ~/.zshrc ]; then
		echo "export REDMINE_API_TOKEN=$red_token" >> ~/.zshrc
	fi

	echo "OK dude. Now you can update any issue passing the CR number by the pushit"
}

init_redmine() {
	REDMINE_API_TOKEN=$( get_redmine_token )
	if [ "$REDMINE_API_TOKEN" == "" ]; then
		read -p "Redmine API TOKEN is missing. Do you wanna set it up now? [y|N] " red
		if [ "$red" == "y" ] || [ "$red" == "Y" ]; then
			config_redmine
		fi

		printf "\n"
		exit 1;
	fi
}

redmine() {
	token=$( get_redmine_token )
	number=$1
	curl -v -H "Content-Type: application/json" -X PUT -d "{ \"issue\": { \"id\": \"$number\", \"status_id\": \"32\" } }" -H "X-Redmine-API-Key: $token" http://suporte.cers.com.br/issues/$number.json
}

pushit() {
	branch=$3
	if [ "$branch" == "" ]; then
		branch="$(git branch | grep '* ' | sed -e 's/* //g')"
	fi

	message="$1$2"
	if [ "$1" == "" ] && [ "$2" == "" ]; then
		printf 'Please, enter the CR number with the option -n, or describe it using the option -m\n\n'
		exit 1;
	fi

	message="CR: #$1 | $2"
	if [ "$1" == "" ]; then
		message="$2"
	fi
	if [ "$2" == "" ]; then
		message="CR: #$1"
	fi

	echo ""
	printf ':: Commit: %s\n' "$message"
	printf ':: Branch: %s\n\n\n' "$branch"

	read -p "Do you want continue? [y|N] " push
	if [ "$push" == "y" ] || [ "$push" == "Y" ]; then
		echo ""
		git add -A && git commit -m "$message" && git pull origin $branch && git push origin $branch

		if [ $1 != "" ]; then
				redmine $1
		fi

	fi

	printf "\nFatality...\n"
}

setup() {
	printf "If you enter 'ctrl + c' will cancel the proccess\n"
	echo "-------------------------------------------"
	echo

	read -p "Enter the CR number: " number
	read -p "Do you wanna put some message? [y|N] " hasMessage

	if [ "$hasMessage" != 'Y' ] && [ "$hasMessage" != 'y' ]; then
		pushit $number
		exit 1;
	fi

	read -p "Commit message: " message
	pushit $number "$message"
}

help() {
	printf '\nUsage:\n'
	printf '  pushit [options] [value]\n\n'

	printf 'Options:\n'
	printf '  %s:\t# This option is preceded by the commit message.\n' "-m"
	printf '  %s:\t# CR number.\n' "-n"
	printf '  %s:\t# git pull: Fetch from and integrate with another repository or a local branch.\n' "-p"
	printf '  %s:\t# Which branch to use. If this option does not be called, the current branch will be used.\n\n' "-b"

	printf 'Pushit Option:\n'
	printf '  %s:\t# Show this help message and quit\n\n' "-h"

	printf 'Description:\n'
	printf '  The pushit command is a shortcut for the git commands.\n'
	printf '  Its the junction of %s ' "git add -A && git commit -m [message] && git pull origin [branch] && git push origin [branch]"
	printf '\n\n'

	printf 'Example:\n'
	printf '  pushit %s 1532 %s' "-n" "-m 'Adjustments to the search method in productDAO' "
	printf '\n\n'
}

version() {
	printf 'version: 2.1.0\n'
}

main() {
	init_redmine

	if [ $# -eq 0 ]; then
		setup
	elif [ $1 == '-h' -o $1 == 'help' ]; then
		help
	elif [ $1 == '-v' -o $1 == 'version' ]; then
		version
	elif [ $1 == '-r' -o $1 == 'redmine' ]; then
		config_redmine
	elif [ $1 == '-p' -o $1 == 'pull' ]; then
		branch="$(git branch | grep '* ' | sed -e 's/* //g')"
		git pull origin $branch
	elif [ $1 == '-s' -o $1 == 'status' ]; then
		git status
	else
		message=''
		number=''
		branch=''
		while getopts ":m:b:n:r:" arg; do
			case $arg in
				m)
					message="$OPTARG"
					;;
				b)
					branch=$OPTARG
					;;
				n)
					number=$OPTARG
					;;
				r)
					redmine="$OPTARG"
					config_redmine $redmine
					exit 1;
					;;
				*)
					printf "Invalid option. Use -h option to open the help text.\n"
					exit 1;
					;;
			esac
		done

		pushit "$number" "$message" "$branch"
	fi

	exit 1;
}


main "$@"
